import{InjectedConnector as I,disconnect as b,connect as s,switchNetwork as O,signTypedData as P,signMessage as E,fetchBalance as j,fetchSigner as $,getNetwork as k,getContract as A,fetchToken as D,readContract as M,writeContract as T,prepareWriteContract as N,watchReadContract as S,fetchEnsAddress as B,fetchEnsAvatar as W,fetchEnsName as R,fetchEnsResolver as q,fetchTransaction as x,prepareSendTransaction as y,sendTransaction as U,waitForTransaction as L}from"@wagmi/core";import{CoinbaseWalletConnector as F}from"@wagmi/core/connectors/coinbaseWallet";import{MetaMaskConnector as H}from"@wagmi/core/connectors/metaMask";import{WalletConnectConnector as z}from"@wagmi/core/connectors/walletConnect";import{jsonRpcProvider as G}from"@wagmi/core/providers/jsonRpc";import{AccountCtrl as u,CoreHelpers as J}from"@web3modal/core";var K=Object.defineProperty,Q=Object.defineProperties,V=Object.getOwnPropertyDescriptors,w=Object.getOwnPropertySymbols,X=Object.prototype.hasOwnProperty,Y=Object.prototype.propertyIsEnumerable,C=(n,e,t)=>e in n?K(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Z=(n,e)=>{for(var t in e||(e={}))X.call(e,t)&&C(n,t,e[t]);if(w)for(var t of w(e))Y.call(e,t)&&C(n,t,e[t]);return n},_=(n,e)=>Q(n,V(e));const f="eip155";let c;function nn(n){n.account&&u.setAddress(n.account),n.chain&&u.setChain(`${f}:${n.chain.id}`,!n.chain.unsupported)}function en(n){console.log(n)}function tn(n){console.log(n)}function rn(){var n,e;const t=(n=c?.data)==null?void 0:n.account,r=(e=c?.data)==null?void 0:e.chain,o=c?.connector,i=c?.provider;t&&r&&o&&i&&(o.on("change",nn),o.on("message",en),o.on("error",tn),u.setAccount({address:t,chainId:`${f}:${r.id}`,chainSupported:!r.unsupported,connector:o.id}))}function an(){var n;(n=c?.connector)==null||n.removeAllListeners(),u.resetAccount()}function cn(n,e){if(n.status!==e.status){const{status:t}=n;t==="connected"&&rn(),t==="disconnected"&&an()}}function on(n){c=n,c.subscribe(cn)}function p(n){if(typeof n=="string"&&n.includes(":"))return Number(n.split(":")[1]);throw new Error("Invalid chainId, should be formated as namespace:id")}function a(n){return _(Z({},n),{chainId:p(n.chainId)})}var sn=Object.defineProperty,h=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,v=Object.prototype.propertyIsEnumerable,g=(n,e,t)=>e in n?sn(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,dn=(n,e)=>{for(var t in e||(e={}))m.call(e,t)&&g(n,t,e[t]);if(h)for(var t of h(e))v.call(e,t)&&g(n,t,e[t]);return n},ln=(n,e)=>{var t={};for(var r in n)m.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&h)for(var r of h(n))e.indexOf(r)<0&&v.call(n,r)&&(t[r]=n[r]);return t};const Cn={walletConnectRpc({projectId:n}){return G({rpc:e=>({http:`https://rpc.walletconnect.com/v1/?chainId=${f}:${e.id}&projectId=${n}`})})},defaultConnectors({appName:n,chains:e}){return[new z({chains:e,options:{qrcode:!1}}),new I({chains:e,options:{shimDisconnect:!0}}),new F({chains:e,options:{appName:n,headlessMode:!0}}),new H({chains:e})]},createClient(n){return on(n),this.getConnectorById("walletConnect").connect(),this},getDefaultConnectorChainId(n){return n.chains[0].id},getConnectorById(n){var e;const t=(e=c)==null?void 0:e.connectors.find(r=>r.id===n);if(!t)throw new Error(`Missing ${n} connector`);return t},async disconnect(){await b(),J.removeWalletConnectDeepLink()},async connectWalletConnect(n){const e=this.getConnectorById("walletConnect"),t=this.getDefaultConnectorChainId(e);async function r(){return new Promise(i=>{e.once("message",async({type:d})=>{if(d==="connecting"){const l=await e.getProvider();n(l.connector.uri),i()}})})}const[o]=await Promise.all([s({connector:e,chainId:t}),r()]);return o},async connectLinking(n){const e=this.getConnectorById("walletConnect"),t=this.getDefaultConnectorChainId(e);async function r(){return new Promise(i=>{e.once("message",async({type:d})=>{if(d==="connecting"){const l=(await e.getProvider()).connector.uri;n(encodeURIComponent(l)),i()}})})}const[o]=await Promise.all([s({connector:e,chainId:t}),r()]);return o},async connectCoinbaseMobile(n){const e=this.getConnectorById("coinbaseWallet"),t=this.getDefaultConnectorChainId(e);async function r(){return new Promise(i=>{e.once("message",async({type:d})=>{if(d==="connecting"){const l=await e.getProvider();n?.(l.qrUrl),i()}})})}const[o]=await Promise.all([s({connector:e,chainId:t}),r()]);return o},async connectCoinbaseExtension(){const n=this.getConnectorById("coinbaseWallet"),e=this.getDefaultConnectorChainId(n);return await s({connector:n,chainId:e})},async connectMetaMask(){const n=this.getConnectorById("metaMask"),e=this.getDefaultConnectorChainId(n);return await s({connector:n,chainId:e})},async connectInjected(){const n=this.getConnectorById("injected"),e=this.getDefaultConnectorChainId(n);return await s({connector:n,chainId:e})},async switchChain(n){return`eip155:${(await O({chainId:p(n)})).id}`},async signTypedData({value:n,domain:e,types:t}){return await P({value:n,domain:e,types:t})},async signMessage(n){return await E({message:n})},async fetchBalance(n){return(await j(a(n))).formatted},async fetchSigner(){return await $()},getNetwork(){return k()},getContract({addressOrName:n,contractInterface:e,signerOrProvider:t}){return A({addressOrName:n,contractInterface:e,signerOrProvider:t})},async getToken({address:n,chainId:e,formatUnits:t}){return await D({address:n,chainId:p(e),formatUnits:t})},async readContract(n){return await M(a(n))},async writeContract(n){return await T(a(dn({mode:"prepared"},n)))},async prepareWriteContract(n){return await N(a(n))},watchReadContract(n){const e=n,{callback:t}=e,r=ln(e,["callback"]);S(a(r),t)},async fetchEnsAddress(n){const e=await B(a(n));return e?.toString()},async fetchEnsAvatar(n){const e=await W(a(n));return e?.toString()},async fetchEnsName(n){const e=await R(a(n));return e?.toString()},async fetchEnsResolver(n){return await q(a(n))},async fetchTransaction(n){return await x(a(n))},async prepareSendTransaction(n){return await y(a(n))},async sendTransaction(n){const e=await y(a(n));return await U({mode:"prepared",request:e.request})},async waitForTransaction(n){return await L(a(n))}};export{Cn as Web3ModalEthereum};
//# sourceMappingURL=index.js.map
